//$ java -cp 'modules\cli\target\classes\;modules\core\target\classes;modules\parser\target\classes;C:\Users\Raymond\.m2\repository\org\antlr\antlr-runtime\3.2\antlr-runtime-3.2.jar;modules\f17\target\classes' org.scribble.f17.main.F17Main modules/f17/src/test/scrib/tmp/Test.scr Proto1

module Test;

// replace a lot of FACTORY name calls by clone
// -minlts states IDs don't match validation output

// CHECKME: playing multiple roles in the same session instance (but what is the concrete notion of "process id"? -- if actually try to use, e.g., ThreadID, then have to track ownership of endpoints)

// - API gen for connection-with-message
// - API gen for wrap (SMTP)
// - API gen for shared channel passing
// - callback API needs generic session-state arg

// - Redo HTTP/SMTP message deserialization (and maybe ScribMsgFormatter i/f) -- deserialization routines should be per-message

// Job modes (full/default, fase17, oldscrib, MPST, etc.) -- factor out GMConfig interface

// FIXME: demo.bettybook.math.MathC cancelledkey exception

// Add a unit test for validation to bypass aux


// - f17 model checking
// - f17 well-formedness (including deterministic, etc.)
// - f17 API generation (connection-with-message, shared channel passing)
// - test WF/projection cases

//*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	rec X
	{
		choice at A
		{
			1() from A to B;
			2() connect B to C;
			disconnect B and C;
			continue X;
		}
		or
		{
			3() from A to B;
		}
	}
}
//*/

/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	1() from A to B;
	connect B to C;
	2() from B to C;
}
//*/

/*
global protocol Proto1(role A, role B)
{
	choice at A  // Testing: f17 model building
	{	
		1() from A to B;
		1() from A to B;
	}
	or
	{
		2() from A to B;
	}	
}
//*/

/*
explicit global protocol Proto1(role C, role A, role S)
{
	connect C to A;  // Testing: TravelAgency
	rec X
	{
		choice at C
		{
			query() from C to A;		
			quote() from A to C;
			continue X;
		}
		or
		{
			pay() connect C to S;
			confirm() from S to C;
			accpt() from C to A;		
		}	
		or
		{
			reject() from C to A;		
		}
	}
}
//*/

/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect	A to B;
	choice at A
	{
		1() from A to B;
	}
	or
	{
		2() from A to B;
		connect B to C;  // Testing: basic explicit connections
		2() from B to C;
	}		
}
//*/

/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		1() from A to C;
	}
	or
	{
		2() from A to B;
		2() from B to C;  // Testing: inconsistent choice subject
	}		
}
//*/

/*
global protocol Proto1(role A, role B)
{
	choice at A  // Testing: mixed-choice -- subsumed by role enabling?
	{
		1() from A to B;
	}
	or
	{
		2() from B to A;
	}
}
//*/

/*
global protocol Proto1(role A, role B, role C)
{
  // Previous (post-inlining): limitation of projection: non-prefix guarded case for A (projected straight to non-unary choice)
  // Now testing: projection-delta, unguarded X for C
	rec X
	{
		0() from B to C;
		choice at A
		{
			1() from A to B;
			//1() from B to C;  // OK if uncommented
			continue X;
		}
		or
		{
			2() from A to B;
			2() from B to C;
		}	
	}
}
//*/

/* 
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		choice at A
		{
			1() from A to B;	 // Testing: unbalanced choice role sets without explicit connections
			continue X;
		}
		or
		{
			2() from A to B;
			2() from B to C;
		}	
	}
}
//*/

/* 
global protocol Proto1(role A, role B)  // Testing: basic syntax structure (e.g., no seq)
{
	1() from A to B;
	1() from A to B;
	choice at A
	{
		1() from A to B;
		choice at A
		{
			1() from A to B;
		}
	}
	or
	{
		2() from A to B;
		rec X
		{
			rec Y
			{
				2() from A to B;
				continue X;
			}
		}
	}
}
//*/

