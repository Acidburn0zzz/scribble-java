//$ java -cp 'modules\cli\target\classes\;modules\core\target\classes;modules\parser\target\classes;C:\Users\Raymond\.m2\repository\org\antlr\antlr-runtime\3.2\antlr-runtime-3.2.jar;modules\f17\target\classes' org.scribble.f17.main.F17Main modules/f17/src/test/scrib/tmp/Test.scr Proto1

module Test;


// - f17 well-formedness (including deterministic, etc.)
// - f17 API generation (connection-with-message, shared channel passing)
// - test WF/projection cases


//*
explicit global protocol Proto1(role A, role B, role C, role D)
{
	connect A to B;
	rec X
	{
		l() from A to B;
		connect C to D;  // Testing: non-terminal safety error (inside terminal set)
		continue X;
	}
}
//*/

/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		l() from A to B;
		rec X
		{
			l() from A to B;  // Testing: progress violation, including under -fair
			continue X;
		}
	}
	or
	{
		l1() from A to B;
		l1() from A to C;
	}
}
//*/

/*/
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		choice at A
		{
			1() from A to B;
			1() from A to C;  // Comment to test: unfair progress
			continue X;
		}
		or
		{
			2() from A to B;
			2() from A to C;
		}	
	}
}
//*/

/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	rec X
	{
		choice at A
		{
			1() from A to B;
			2() connect B to C;
			disconnect B and C;
			continue X;
		}
		or
		{
			3() from A to B;
		}
	}
}
//*/

/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	1() from A to B;
	connect B to C;
	2() from B to C;
}
//*/

/*
global protocol Proto1(role A, role B)
{
	choice at A  // Testing: f17 model building
	{	
		1() from A to B;
		1() from A to B;
	}
	or
	{
		2() from A to B;
	}	
}
//*/

/*
explicit global protocol Proto1(role C, role A, role S)
{
	connect C to A;  // Testing: TravelAgency
	rec X
	{
		choice at C
		{
			query() from C to A;		
			quote() from A to C;
			continue X;
		}
		or
		{
			pay() connect C to S;
			confirm() from S to C;
			accpt() from C to A;		
		}	
		or
		{
			reject() from C to A;		
		}
	}
}
//*/

/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect	A to B;
	choice at A
	{
		1() from A to B;
	}
	or
	{
		2() from A to B;
		connect B to C;  // Testing: basic explicit connections
		2() from B to C;
	}		
}
//*/

/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		1() from A to C;
	}
	or
	{
		2() from A to B;
		2() from B to C;  // Testing: inconsistent choice subject
	}		
}
//*/

/*
global protocol Proto1(role A, role B)
{
	choice at A  // Testing: mixed-choice -- subsumed by role enabling?
	{
		1() from A to B;
	}
	or
	{
		2() from B to A;
	}
}
//*/

/*
global protocol Proto1(role A, role B, role C)
{
  // Previous (post-inlining): limitation of projection: non-prefix guarded case for A (projected straight to non-unary choice)
  // Now testing: projection-delta, unguarded X for C
	rec X
	{
		0() from B to C;
		choice at A
		{
			1() from A to B;
			//1() from B to C;  // OK if uncommented
			continue X;
		}
		or
		{
			2() from A to B;
			2() from B to C;
		}	
	}
}
//*/

/* 
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		choice at A
		{
			1() from A to B;	 // Testing: unbalanced choice role sets (without explicit connections) -- OK if -fair
			continue X;
		}
		or
		{
			2() from A to B;
			2() from B to C;
		}	
	}
}
//*/

/* 
global protocol Proto1(role A, role B)  // Testing: basic syntax structure (e.g., no seq)
{
	1() from A to B;
	1() from A to B;
	choice at A
	{
		1() from A to B;
		choice at A
		{
			1() from A to B;
		}
	}
	or
	{
		2() from A to B;
		rec X
		{
			rec Y
			{
				2() from A to B;
				continue X;
			}
		}
	}
}
//*/

